#!/usr/bin/env bash

#------------------------------------------------------------------------------
# @file
# Performs assertion testing of the functions in this library.
#
#------------------------------------------------------------------------------

set +u    # подключаем внешнюю "библиотеку"
[[ ${_GUARD_BFL_AUTOLOAD} -eq 1 ]] || { . /etc/getConsts || exit 1; . "${BASH_FUNCTIONS_LIBRARY}"; }

#------------------------------------------------------------------------------
# @function
#   Tests a function to see if its return code matches the expected return code.
#
# @param String $function_to_test
#   The function to be tested.
#
# @param String $args
#   The arguments to pass to the function.
#
# @param String $expected_return_code
#   The expected return code (0 or 1).
#
# shellcheck disable=SC2059
# shellcheck disable=SC2154
#------------------------------------------------------------------------------
assert() {
  [[ $# -eq 3 ]] || { bfl::error "arguments count $# ≠ 3"; return ${BFL_ErrCode_Not_verified_args_count}; }

  local -r function_to_test="$1"
  local -r args="$2"
  local -r expected_return_code="$3"

  # Test for empty strings.
  bfl::is_blank "${function_to_test}"     && { bfl::error "\$function_to_test is required.";     return 1; }
  bfl::is_blank "${expected_return_code}" && { bfl::error "\$expected_return_code is required."; return 1; }

  local {cmd,cmd_output,format,result}=
  local -i iErr

  # Run the command. The command is run in a subshell (command substitution);
  # exit calls will terminate the subshell, not this script.
  cmd=$(printf "%s %s" "${function_to_test}" "${args}")
  cmd_output=$(eval "${cmd}" 2>&1)
  iErr=$?

  # Print results.
  if [[ ${iErr} -eq "${expected_return_code}" ]]; then
      result="PASS"
      format="${bfl_aes_green}%-${cw1}s${bfl_aes_reset} %-${cw2}s %-${cw3}s %-${cw4}s %-${cw5}s %-${cw6}s${bfl_aes_reset} \\n"
  else
      result="FAIL"
      format="${bfl_aes_red}%-${cw1}s${bfl_aes_reset} %-${cw2}s %-${cw3}s %-${cw4}s %-${cw5}s %-${cw6}s${bfl_aes_reset} \\n"
  fi
  cmd_output=${cmd_output//[$'\n']}
  printf "${format}" "${result}" "${function_to_test:0:${cw2}}" "${args:0:${cw3}}" "${expected_return_code}" "${iErr}" "${cmd_output:0:${cw6}}"
  }

#------------------------------------------------------------------------------
# @function
#   Main function.
#
# @param array global $assertions
#   Global array created by declare_assertions().
#
# shellcheck disable=SC1090
# shellcheck disable=SC2034
# shellcheck disable=SC2059
#------------------------------------------------------------------------------
main() {
  # Declare column widths (global constants) for displaying test results.
  readonly cw1=6     # Width of column 1: Result (PASS/FAIL)
  readonly cw2=37    # Width of column 2: Function
  readonly cw3=33    # Width of column 3: Arguments
  readonly cw4=8     # Width of column 4: Expected return code
  readonly cw5=6     # Width of column 5: Actual return code
  readonly cw6=109   # Width of column 6: Command output

# columns width:   Result Function Arguments  returncode    output
# readonly cw_arr=(   6      37        33       8     6      109 )
#                 PASS/FAIL                 Expected Actual

  # Declare other local variables.
  local -r format="%-${cw1}s %-${cw2}s %-${cw3}s %-${cw4}s %-${cw5}s %-${cw6}s"
  local {assertion,line_1,line_2,line_3,line_4,line_5,line_6}=
  local -a pieces

  # Create table header lines for for displaying test results.
  line_1=$(bfl::repeat "=" ${cw1})
  line_2=$(bfl::repeat "=" ${cw2})
  line_3=$(bfl::repeat "=" ${cw3})
  line_4=$(bfl::repeat "=" ${cw4})
  line_5=$(bfl::repeat "=" ${cw5})
  line_6=$(bfl::repeat "=" ${cw6})

  clear  # Clear the screen.
  printf "\\n"  # Print initial newline.

  # Print table header.
  printf "${format}\\n" "" "" "" "Expected" "Actual" ""
  printf "${format}\\n" "" "" "" "Return" "Return" ""
  printf "${format}\\n" "Result" "Function" "Arguments (truncated)" "Code" "Code" "First line of command output (truncated)"
  printf "%s %s %s %s %s %s\\n" "${line_1}" "${line_2}" "${line_3}" "${line_4}" "${line_5}" "${line_6}"

  for d in "${BASH_FUNCTIONS_LIBRARY%/*}"/lib/*; do
      d="${d##*/}"
      if [[ -f "${BASH_FUNCTIONS_LIBRARY%/*}"/test/"$d" ]]; then  #  && ! [[ "$d" = 'test' ]]
          printf "\n" 2>&1
          printf "Testing $d library...\n" 2>&1
          printf "\n" 2>&1

          source "${BASH_FUNCTIONS_LIBRARY%/*}"/test/"$d"
          declare_assertions # Declare assertions.

          # Run assertion tests.
          for assertion in "${assertions[@]}"; do
              IFS="|" read -r -a pieces <<< "${assertion}"
              # called function        arguments    return code
              assert "${pieces[0]}" "${pieces[1]}" "${pieces[2]}" || true
          done
      fi
  done

  # Print final newline.
  printf "\\n"
  }

#set -euo pipefail
main
