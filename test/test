#!/usr/bin/env bash

#------------------------------------------------------------------------------
# @file
# Performs assertion testing of the functions in this library.
#
#------------------------------------------------------------------------------

#------------------------------------------------------------------------------
# @function
# Tests a function to see if its return code matches the expected return code.
#
# @param string $function_to_test
#   The function to be tested.
# @param string $args
#   The arguments to pass to the function.
# @param string $expected_return_code
#   The expected return code (0 or 1).
#
# shellcheck disable=SC2059
# shellcheck disable=SC2154
#------------------------------------------------------------------------------
assert() {
  bfl::verify_arg_count "$#" 3 3 || exit 1

  declare -r function_to_test="$1"
  declare -r args="$2"
  declare -r expected_return_code="$3"
  declare actual_return_code
  declare cmd
  declare cmd_output
  declare format
  declare result

  # Test for empty strings.
  bfl::is_empty "${function_to_test}"     && bfl::die "\$function_to_test is a an empty string."
  bfl::is_empty "${expected_return_code}" && bfl::die "\$expected_return_code is a an empty string."

  # Run the command. The command is run in a subshell (command substitution);
  # exit calls will terminate the subshell, not this script.
  cmd=$(printf "%s %s" "${function_to_test}" "${args}")
  cmd_output=$(eval "${cmd}" 2>&1)
  actual_return_code="$?"

  # Print results.
  if [[ "${actual_return_code}" -eq "${expected_return_code}" ]]; then
      result="PASS"
      format="${bfl_aes_green}%-${cw1}s${bfl_aes_reset} %-${cw2}s %-${cw3}s %-${cw4}s %-${cw5}s %-${cw6}s${bfl_aes_reset} \\n"
  else
      result="FAIL"
      format="${bfl_aes_red}%-${cw1}s${bfl_aes_reset} %-${cw2}s %-${cw3}s %-${cw4}s %-${cw5}s %-${cw6}s${bfl_aes_reset} \\n"
  fi
  cmd_output=${cmd_output//[$'\n']}
  printf "${format}" "${result}" "${function_to_test:0:${cw2}}" "${args:0:${cw3}}" "${expected_return_code}" "${actual_return_code}" "${cmd_output:0:${cw6}}"
  }

#------------------------------------------------------------------------------
# @function
# Main function.
#
# @param array global $assertions
#   Global array created by declare_assertions().
#
# shellcheck disable=SC1090
# shellcheck disable=SC2034
# shellcheck disable=SC2059
#------------------------------------------------------------------------------
main() {
  if ! source "${BASH_FUNCTION_LIBRARY}"; then
      printf "Error. Unable to source BASH_FUNCTION_LIBRARY.\\n" 1>&2
      exit 1
  fi

  # Declare column widths (global constants) for displaying test results.
  declare -rg cw1=6     # Width of column 1: Result (PASS/FAIL)
  declare -rg cw2=37    # Width of column 2: Function
  declare -rg cw3=33    # Width of column 3: Arguments
  declare -rg cw4=8     # Width of column 4: Expected return code
  declare -rg cw5=6     # Width of column 5: Actual return code
  declare -rg cw6=109   # Width of column 6: Command output

  # Declare other local variables.
  declare assertion
  declare -r format="%-${cw1}s %-${cw2}s %-${cw3}s %-${cw4}s %-${cw5}s %-${cw6}s"
  declare line_1 line_2 line_3 line_4 line_5 line_6
  declare -a pieces

  # Create table header lines for for displaying test results.
  line_1=$(bfl::repeat "=" ${cw1})
  line_2=$(bfl::repeat "=" ${cw2})
  line_3=$(bfl::repeat "=" ${cw3})
  line_4=$(bfl::repeat "=" ${cw4})
  line_5=$(bfl::repeat "=" ${cw5})
  line_6=$(bfl::repeat "=" ${cw6})

  clear  # Clear the screen.
  printf "\\n"  # Print initial newline.

  # Print table header.
  printf "${format}\\n" "" "" "" "Expected" "Actual" ""
  printf "${format}\\n" "" "" "" "Return" "Return" ""
  printf "${format}\\n" "Result" "Function" "Arguments (truncated)" "Code" "Code" "First line of command output (truncated)"
  printf "%s %s %s %s %s %s\\n" "${line_1}" "${line_2}" "${line_3}" "${line_4}" "${line_5}" "${line_6}"

  #
  for d in lib/*; do
      d="${d##*/}"
      if [[ -f test/"$d" ]]; then  #  && ! [[ "$d" = 'test' ]]
          printf "Testing $d library...\n" > /dev/tty

          source test/"$d"
          declare_assertions # Declare assertions.

          # Run assertion tests.
          for assertion in "${assertions[@]}"; do
              IFS="|" read -r -a pieces <<< "${assertion}"
              # called function        arguments    return code
              assert "${pieces[0]}" "${pieces[1]}" "${pieces[2]}" || true
          done
      fi
  done

  # Print final newline.
  printf "\\n"
  }

set -euo pipefail
main
